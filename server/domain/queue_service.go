package domain

import (
	"context"
	"fmt"
	"sync"
)

// QueueService ?????????????????
// ????????????????????
type QueueService interface {
	// EnqueueOCRTask OCR??????????
	EnqueueOCRTask(ctx context.Context, filename string, storageProvider string) error
	
	// DequeueOCRTask ?????OCR????????
	DequeueOCRTask(ctx context.Context) (*OCRTask, error)
}

// OCRTask ?OCR??????
type OCRTask struct {
	Filename        string
	StorageProvider string
}

// queueServiceInstances ???????????????????????????????
// ?????????????????????1????????????
var (
	queueServiceInstances = make(map[string]QueueService)
	queueServiceMutex     sync.Mutex
)

// NewQueueService ????????????????????????????????
// ????????????????????????????
func NewQueueService(storageProvider string) (QueueService, error) {
	queueServiceMutex.Lock()
	defer queueServiceMutex.Unlock()
	
	// ??????????????
	if instance, exists := queueServiceInstances[storageProvider]; exists {
		return instance, nil
	}
	
	// ???????????????????????????
	var instance QueueService
	switch storageProvider {
	case "s3":
		// AWS: Localstack SQS???
		instance = NewLocalstackSQSService()
	case "gcs":
		// GCP: Pub/Sub???
		instance = NewGCPPubSubService()
	case "azure":
		// Azure: Azurite Queue Storage???????10001?
		instance = NewAzuriteQueueService()
	default:
		// ?????: in-memory???????
		instance = NewCommonQueueService()
	}
	
	// ?????????
	queueServiceInstances[storageProvider] = instance
	return instance, nil
}

// commonQueueService ???????in-memory???????
// ??????????????????
type commonQueueService struct {
	tasks chan *OCRTask
}

// NewCommonQueueService ?????????????
func NewCommonQueueService() QueueService {
	return &commonQueueService{
		tasks: make(chan *OCRTask, 100), // ???????100
	}
}

func (q *commonQueueService) EnqueueOCRTask(ctx context.Context, filename string, storageProvider string) error {
	task := &OCRTask{
		Filename:        filename,
		StorageProvider: storageProvider,
	}
	
	select {
	case q.tasks <- task:
		return nil
	case <-ctx.Done():
		return ctx.Err()
	default:
		return fmt.Errorf("queue is full")
	}
}

func (q *commonQueueService) DequeueOCRTask(ctx context.Context) (*OCRTask, error) {
	select {
	case task := <-q.tasks:
		return task, nil
	case <-ctx.Done():
		return nil, ctx.Err()
	}
}

// ?: ????????????????????????????????????:
// - sqs_queue_service.go: AWS SQS (Localstack)
// - azure_queue_service.go: Azure Queue Storage (Azurite)
// - pubsub_queue_service.go: GCP Pub/Sub
