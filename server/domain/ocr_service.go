package domain

import (
	"context"
	"image"
	"io"
	"sync"
	"time"
)

// OCREngine ?OCR????????????????
// ???OCR?????Tesseract?EasyOCR?PaddleOCR??????????
type OCREngine interface {
	// Name ??????????"tesseract", "easyocr", "paddleocr"?
	Name() string
	
	// ProcessDocument ???????????OCR?????
	ProcessDocument(ctx context.Context, filename string, content io.Reader) (*OCRResult, error)
	
	// ProcessImage ???????OCR??????PDF???????????
	ProcessImage(ctx context.Context, img image.Image) (string, float64, error)
	// ???: (extracted_text, confidence, error)
}

// OCRResult ?OCR????????
type OCRResult struct {
	StorageProvider string // "azure", "s3", "gcs" - Added for persistence
	Filename        string
	EngineName     string // "tesseract", "easyocr", "paddleocr"
	ExtractedText   string
	Pages           []OCRPage
	Status         string // "processing", "completed", "failed"
	Error           error
	ProcessedAt     time.Time
	Confidence     float64 // ?????
}

// OCRPage ?????????1?????OCR??
type OCRPage struct {
	PageNumber int
	Text       string
	Confidence float64
}

// OCRService ????OCR????????????????????
type OCRService interface {
	// ProcessDocument ??????????????????
	ProcessDocument(ctx context.Context, filename string, content io.Reader, engineNames []string) (map[string]*OCRResult, error)
	
	// RegisterEngine ?OCR?????????
	RegisterEngine(engine OCREngine)
	
	// ListEngines ????????????????
	ListEngines() []string
	
	// GetEngine ??????????????????
	GetEngine(name string) OCREngine
}

// ocrService ?OCRService???
type ocrService struct {
	engines map[string]OCREngine
	mu      sync.RWMutex
}

// NewOCRService ????OCRService?????
func NewOCRService() OCRService {
	return &ocrService{
		engines: make(map[string]OCREngine),
	}
}

// RegisterEngine ?OCR?????????
func (s *ocrService) RegisterEngine(engine OCREngine) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.engines[engine.Name()] = engine
}

// ListEngines ????????????????
func (s *ocrService) ListEngines() []string {
	s.mu.RLock()
	defer s.mu.RUnlock()
	
	names := make([]string, 0, len(s.engines))
	for name := range s.engines {
		names = append(names, name)
	}
	return names
}

// GetEngine ??????????????????
func (s *ocrService) GetEngine(name string) OCREngine {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.engines[name]
}

// ProcessDocument ????OCR??????????????
func (s *ocrService) ProcessDocument(ctx context.Context, filename string, content io.Reader, engineNames []string) (map[string]*OCRResult, error) {
	if len(engineNames) == 0 {
		// ???????????????????
		s.mu.RLock()
		for name := range s.engines {
			engineNames = append(engineNames, name)
		}
		s.mu.RUnlock()
	}
	
	results := make(map[string]*OCRResult)
	var wg sync.WaitGroup
	var mu sync.Mutex
	
	for _, engineName := range engineNames {
		engine := s.GetEngine(engineName)
		if engine == nil {
			// ??????????????????
			continue
		}
		
		wg.Add(1)
		go func(name string, eng OCREngine) {
			defer wg.Done()
			
			// ?????????????????????
			// ??????????????????????????
			// ???????????????????io.Reader???
			// ???????????Read?????io.TeeReader??????
			result, err := eng.ProcessDocument(ctx, filename, content)
			if err != nil {
				result = &OCRResult{
					Filename:   filename,
					EngineName: name,
					Status:     "failed",
					Error:      err,
					ProcessedAt: time.Now(),
				}
			}
			
			mu.Lock()
			results[name] = result
			mu.Unlock()
		}(engineName, engine)
	}
	
	wg.Wait()
	return results, nil
}
