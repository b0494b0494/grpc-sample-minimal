package domain

import (
	"context"
	"fmt"
	"io"
	"os"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	pb "grpc-sample-minimal/proto"
)

// OCRClient ?OCR?????????????????????????????????
// gRPC?????????OCR?????????
type OCRClient interface {
	// ProcessDocument ???????????OCR?????
	ProcessDocument(ctx context.Context, filename string, content io.Reader, storageProvider string) (*OCRResult, error)
	
	// GetOCRResult ?OCR???????
	GetOCRResult(ctx context.Context, filename string, storageProvider string, engineName string) (*OCRResult, error)
	
	// Close ???????
	Close() error
}

// ocrClientAdapter ?OCRClient????????
// gRPC?????????OCR?????????
type ocrClientAdapter struct {
	grpcClient pb.GreeterClient // gRPC?????????????
	conn       *grpc.ClientConn  // ?????
	authToken  string            // ??????
}

// NewOCRClient ?OCR???????????
// endpoint: OCR?????gRPC?????????: "ocr-service:50052"?
// authToken: ??????
func NewOCRClient(endpoint string, authToken string) (OCRClient, error) {
	// gRPC?????
	conn, err := grpc.Dial(endpoint, grpc.WithInsecure())
	if err != nil {
		return nil, fmt.Errorf("failed to connect to OCR service: %w", err)
	}
	
	client := pb.NewGreeterClient(conn)
	
	return &ocrClientAdapter{
		grpcClient: client,
		conn:       conn,
		authToken:  authToken,
	}, nil
}

// ProcessDocument ???????OCR??????gRPC????????????
func (c *ocrClientAdapter) ProcessDocument(ctx context.Context, filename string, content io.Reader, storageProvider string) (*OCRResult, error) {
	// gRPC????????
	req := &pb.OCRRequest{
		Filename:       filename,
		StorageProvider: storageProvider,
	}
	
	// ???????????????
	md := metadata.New(map[string]string{
		"authorization": c.getAuthToken(ctx),
	})
	ctx = metadata.NewOutgoingContext(ctx, md)
	
	// OCR???????????????????????gRPC?????????????
	// resp??????????????????ID??????????????????????
	_, err := c.grpcClient.ProcessOCR(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to process OCR: %w", err)
	}
	
	// ???????????????????
	// taskID???????GetOCRResult??????
	return &OCRResult{
		Filename:        filename,
		StorageProvider: storageProvider,
		Status:          "processing", // ???
		// TaskID?resp?????????OCRResult??????
	}, nil
}

// GetOCRResult ?OCR????????gRPC?????????????
func (c *ocrClientAdapter) GetOCRResult(ctx context.Context, filename string, storageProvider string, engineName string) (*OCRResult, error) {
	req := &pb.OCRResultRequest{
		Filename:       filename,
		StorageProvider: storageProvider,
		EngineName:     engineName,
	}
	
	// ???????????????
	md := metadata.New(map[string]string{
		"authorization": c.getAuthToken(ctx),
	})
	ctx = metadata.NewOutgoingContext(ctx, md)
	
	resp, err := c.grpcClient.GetOCRResult(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get OCR result: %w", err)
	}
	
	// pb.OCRResultResponse?domain.OCRResult???
	pages := make([]OCRPage, len(resp.Pages))
	for i, page := range resp.Pages {
		pages[i] = OCRPage{
			PageNumber: int(page.PageNumber),
			Text:       page.Text,
			Confidence: page.Confidence,
		}
	}
	
	var errObj error
	if resp.ErrorMessage != "" {
		errObj = fmt.Errorf(resp.ErrorMessage)
	}
	
	return &OCRResult{
		Filename:        resp.Filename,
		StorageProvider: storageProvider,
		EngineName:      resp.EngineName,
		ExtractedText:   resp.ExtractedText,
		Pages:           pages,
		Status:          resp.Status,
		Error:           errObj,
		Confidence:      resp.Confidence,
		ProcessedAt:     timeFromUnix(resp.ProcessedAt),
	}, nil
}

// Close ?gRPC??????
func (c *ocrClientAdapter) Close() error {
	if c.conn != nil {
		return c.conn.Close()
	}
	return nil
}

// getAuthToken ????????????
func (c *ocrClientAdapter) getAuthToken(ctx context.Context) string {
	if c.authToken != "" {
		return c.authToken
	}
	// ????????
	if token := os.Getenv("AUTH_TOKEN"); token != "" {
		return token
	}
	return ""
}

// timeFromUnix ?Unix?????????time.Time???
func timeFromUnix(ts int64) time.Time {
	if ts == 0 {
		return time.Time{}
	}
	return time.Unix(ts, 0)
}
